# LoRE-SD: Local Response Function Representation in Spherical Deconvolution

**LoRE-SD** is a novel diffusion MRI modelling technique making minimal assumptions on tissue microstructure. It is based on the spherical deconvolution paradigm in which the diffusion signal is decomposed as the spherical convolution of a response function $R$ and and ODF $F$.

$$
S\left(\theta,\phi\right)=R\left(\theta\right)\ast F\left(\theta,\;\phi\right)
$$

LoRE-SD estimates the response function $F$ in every voxel. The response function is represented as a linear combination of Gaussian basis functions. Each Gaussian basis function $G$ is parameterised by an axial ($\lambda_\parallel$) and radial diffusivity ($\lambda_\perp$). By default, LoRE-SD uses a 10 by 10 grid of equally spaced $\lambda_\parallel$ and $\lambda_\perp$ values in the range $[0,4] \; \mu m^2/ms$. In line with physics, the radial diffusivity must be less than or equal to the axial diffusivity for each basis functions, effectively discarding half of the square grid.

Every Gaussian basis function is associated with a weight $0 \le f_{\lambda_\parallel, \lambda_\perp} \le 1$. During optimisation then, these weights are optimised along with the ODF coefficients. A regularisation term promoting more isotropic response functions is employed to promote ODF sparsity and reduce erroneous ODF peaks.

The response function representation is used to generate scalar image maps mimicking an intra-axonal, extra-axonal and free water compartment. This is achieved by creating weight matrices that accentuate ($\lambda_\parallel, \lambda\perp$) combinations of interest. E.g. an intra-axonal compartment can me mimicked by multiplying the response function representation in every voxel with a weight matrix with large weights for basis functions with small $\lambda_\perp$ and low weights for basis functions with large $\lambda_\perp$.


In summary, LoRE-SD offers a framework for estimating data-driven, local response functions, enabling accurate glioma modelling and the development of new image contrasts.

This code makes use of MRtrix3 commands. Make sure you have a working installation installed and have added the binaries to your PATH.

## Usage
1. Install the required dependencies: 
    1.1 python
    1.2 numpy
    1.3 matplotlib
    1.4 scipy
    1.5 tqdm (progress bar)
    1.6 MRtrix3
2. Run the LoRE-SD algorithm on your dMRI data:
    `python src/dwi2decomposition.py <input_dwi> <output_dir> [--reg <regularisation_parameter>] [--grid_size <grid_size>] [--cores <number_of_cores>] [--bvecs <bvecs>] [--bvals <bvals>]`
    * `<input_dwi>`: Inut DWI in MRtrix3 format (.mif) or NIfTI format (.nii.gz)
    * `<output_dir>`: Directory to write the output files to. Output files are `odf.mif`, `response.mif` and `gaussian_fractions.mif`
    * `--reg <regularisation_parameter>`: (optional) Default is $10^{-3}$
    * `--grid_size <grid_size>`: (optional) Default is 10. This is the square grid size of the response function representation. Values are always linearly separated in $[0, 4] \mu m^2/ms$.
    * `--cores <number_of_cores>`: (optional) Default is 1. Number of cores to use for multiprocessing. As a reference, using 50 cores takes about 5 minutes to process a full DWI of the brain.
    * `--bvecs <bvecs> --bvals <bvals>`: Paths to bvecs and bvals file respectively if using NIfTI format.
3. Analyze the ODF estimates and generated image contrasts. The basic image contrasts can be generated using:
    `python src/decomposition2contrast.py <input_fractions> <output_dir>`
    * `<input_fractions>`: Gaussian fractions estimated by LoRE-SD. Supplying `gaussian_fractions.mif` suffices.
    * `<output_dir>`: Directory to write the output files to. Output files are `intra_axonal_constrast.mif`, `extra_axonal_contrast.mif` and `free_water_contrast.mif`

    New contrasts can be generated by defining a contrast matrix which assigns a weight $0 \le w_{\lambda_\parallel, \lambda_\perp} \le 1$ to every Gaussian basis function $G_{\lambda_\parallel, \lambda_\perp}$ and calculating the inner product of this matrix with `gaussian_fractions.mif`. For the example contrasts, see src/optimisation/contrasts.py

Given two .mif files with ODF coefficients, the following command lets you calculate the Angular Correlation Coefficient between the ODFs in every voxel. This functionality is useful when comparing ODF estimates of LoRE-SD to those of MSMT-CSD.
`python src/angular_correlation.py <ODF1> <ODF2> <output_file>`

## Notebooks for replications
Voxel-level simulations and a hyperparameter validation are provided as Jupyter notebooks in 'Voxel Simulation.ipynb' and 'Hyperparameter Tuning.ipynb' respectively. If all the correct dependencies have been installed, these should run without a problem as they create the simulated data at runtime.


## Authors
- Siebe Leysen


